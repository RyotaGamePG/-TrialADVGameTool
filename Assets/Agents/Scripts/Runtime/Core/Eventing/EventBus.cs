// Generated by agent: 2025-10-07
using System;
using System.Collections.Generic;

namespace Agents.Runtime.Core.Eventing
{
    /// <summary>
    /// Simple event bus implementation that keeps GC pressure low by reusing handler lists.
    /// </summary>
    public sealed class EventBus : IEventBus, IDisposable
    {
        private readonly Dictionary<Type, List<Delegate>> _handlerCache = new Dictionary<Type, List<Delegate>>(32);
        private bool _disposed;

        public void Publish<TEvent>(TEvent payload)
        {
            if (_disposed)
            {
                throw new ObjectDisposedException(nameof(EventBus));
            }

            var eventType = typeof(TEvent);
            if (!_handlerCache.TryGetValue(eventType, out var handlers))
            {
                return;
            }

            var count = handlers.Count;
            for (var i = 0; i < count; i++)
            {
                if (handlers[i] is Action<TEvent> callback)
                {
                    callback(payload);
                }
            }
        }

        public void Subscribe<TEvent>(Action<TEvent> handler)
        {
            if (_disposed)
            {
                throw new ObjectDisposedException(nameof(EventBus));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            var eventType = typeof(TEvent);
            if (!_handlerCache.TryGetValue(eventType, out var handlers))
            {
                handlers = new List<Delegate>(4);
                _handlerCache[eventType] = handlers;
            }

            if (!handlers.Contains(handler))
            {
                handlers.Add(handler);
            }
        }

        public void Unsubscribe<TEvent>(Action<TEvent> handler)
        {
            if (_disposed)
            {
                return;
            }

            var eventType = typeof(TEvent);
            if (!_handlerCache.TryGetValue(eventType, out var handlers))
            {
                return;
            }

            handlers.Remove(handler);
        }

        public void Dispose()
        {
            if (_disposed)
            {
                return;
            }

            foreach (var pair in _handlerCache)
            {
                pair.Value.Clear();
            }

            _handlerCache.Clear();
            _disposed = true;
        }
    }
}
